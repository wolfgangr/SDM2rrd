#!/usr/bin/perl
# create rrds for SDM data logging matching our definitions around here

our $usage = <<"EOF_USAGE";
usage: $0 [ options ]
  -D		dryrun
  -t		touch file only
  -f		force_overwrite
  -a		ask before each creation
  -s		create shell creator skripts instead of executing

  -d dir 	alternateve rrd dir
  -p prefix	alternative rrd prefix

  -c cnt_tag	counter matching tag only
  -r rrd_tag	rrd matching tag only
  -l		list counters and rrds

  -v level	set verbosity level
  -q		suppress explaining output
  -h		print this message
  
EOF_USAGE

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
use warnings;
use strict;

use Getopt::Std;
use  RRDs;
use DateTime;
use Data::Dumper  ;


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

our $Debug = 3;
require ('./my_debugs.pl');



my $retval = getopts('Dtfasd:p:c:r:lv:qh');
our ( $opt_D , $opt_t , $opt_f , $opt_a , $opt_s,  $opt_d , $opt_p , 
	$opt_c , $opt_r , $opt_l , $opt_v , $opt_q, $opt_h , ) ; 

die "$usage" unless ($retval) ;
die "$usage" if  $opt_h  ;
$Debug = $opt_v if $opt_v ;

# if 

our $sdm_def_file;
our (@SDM_regs , %SDM_reg_by_tag , %SDM_selectors);
require ('./extract-SDM-def.pm');

our %Counterlist;
our @all_selectors;
require ('./my_counters.pm');


our ( $RRD_dir , $RRD_prefix , $RRD_sprintf );
our %RRD_definitions ;
require ('./rrd_def.pm');

if ($opt_d) { $RRD_dir = $opt_d ; }
if ($opt_p) { $RRD_prefix = $opt_p ; }

my @counters = sort keys %Counterlist;
my @rrddefs  = sort keys %RRD_definitions;

if ($opt_l) {
	print "params expand to rrd file template: ";
	printf ($RRD_sprintf, $RRD_dir, $RRD_prefix , '<counter>', '<rrd-def>');
	print "\n";

	print "  - available counters:  ";
	print join ( ' ', @counters), "\n";
	print "  - available rrd defs:  ";
	print join ( ' ', @rrddefs), "\n";
	print "\n";

	exit ;
}

foreach my $counter (@counters) {
    @rrddefs = @{$Counterlist{ $counter }->{ rrds }};
    next if ( $opt_c and ( $opt_c ne $counter ));
         
    foreach my $rrd_d (@rrddefs) {
      next if ( $opt_r and ( $opt_r ne $rrd_d  ));

      my $current_rrd = sprintf ($RRD_sprintf, $RRD_dir, $RRD_prefix , $counter,  $rrd_d );
      print "  - processing $current_rrd ... \n" unless ($opt_q) ;
      
      if ($opt_a) { print "    press <ENTER> to continue\n"; <STDIN> ;} 
      next if ($opt_D) ;

      if ((-e $current_rrd) and ! $opt_f and ! $opt_s ) {
	 print "cowardly refusing to overwrite existing file $current_rrd - use [-f] option to override \n";
	 next;
      } 

      if ($opt_t) {
	 `touch $current_rrd `;
	  next ; 
      }

      # time to do real work
      my $rrd_dhp = $RRD_definitions{$rrd_d} ;
      my @fields  = @{$rrd_dhp->{ fields    }} ;
      my $rradef    = $rrd_dhp->{ rradef    } ;
      my $step      = $rrd_dhp->{ step      } ;
      my $heartbeat = $rrd_dhp->{ heartbeat } ;

      print Data::Dumper->Dump ( [ $rrd_dhp, \@fields , $rradef ], 
	      		[ qw(      *rrd_dhp   *fields   *rradef ) ] );


      my $rrdtool =`which rrdtool` or die "could not find rrdtool executable on this system";
      chomp $rrdtool ;
      our $nl = " \\\n";

      my $cmd = <<'HEAD';
#!/bin/bash
# skript to generate rrd files
# generated by 
HEAD

      $cmd .= "# $0 $nl";
      $cmd .= "$rrdtool create $current_rrd --start NOW";
      $cmd .= sprintf (" --step %d ", $step );
      $cmd .=  $nl;

      foreach my $ds (@fields) {
        $cmd .= sprintf "DS:%s:GAUGE:%s:U:U%s", $ds, $heartbeat, $nl ;
      }

      # replace ordinary \n by shell type ' \<nl>'
      $cmd .= join $nl, (split '\n', $rradef ) ;

      my $FH;
      if ($opt_s) {  # write shell script instead of rrd
	      printf "rdd file name %s replaced  by ",  $current_rrd ;
	      $current_rrd =~ s/(.*)\.rrd$/$1_create.sh/ 
		      	or die  "can't create .sh file name";
	      print $current_rrd, "\n"; 

	      open ( $FH, '>', $current_rrd) or die "cannot write to $current_rrd : $!";
      } else {
		my $x_bash = `which bash` or die "could not find bash executable on this system";
		chomp $x_bash;
		open ( $FH, '|-', $x_bash ) or die "cannot open pipe to bash $!";
      }
	      
       print $FH $cmd;
       close $FH ;

      
      # print "\n--------------------------\n$cmd \n--------------------------\n";

      # die "========= still to do ==========";
  }
}


# die "#### ~~~~~~~~~~~~ Baustelle ~~~~~~~~~~~~ ####";
# regular exit
#
